# Production конфигурация для использования внешних утилит сервера
# Использование: docker compose -f docker-compose.prod.yml up -d
# Этот файл полностью независим и не наследует docker-compose.yml

services:
  # Flask приложение - использует внешний PostgreSQL на хосте
  webapp:
    build:
      context: ../..
      dockerfile: config/docker/Dockerfile
    container_name: flask-app
    # Загружаем переменные окружения из .env файла
    env_file:
      - .env
    environment:
      # Подключение к внешнему PostgreSQL на хосте
      # Используем host.docker.internal для доступа к хосту из контейнера
      # Или можно использовать IP адрес сервера напрямую
      # Переменные из .env файла будут использованы, если не указаны явно
      PG_HOST: ${PG_HOST:-host.docker.internal}
      PG_PORT: ${PG_PORT:-5432}
      PG_DB: ${PG_DB:-test_db}
      PG_USER: ${PG_USER:-postgres}
      PG_PASSWORD: ${PG_PASSWORD:-postgres}
    ports:
      - "5000:5000"
    # Добавляем extra_hosts для доступа к хосту
    extra_hosts:
      - "host.docker.internal:host-gateway"
    # Используем network_mode: host для прямого доступа к хосту (альтернатива)
    # network_mode: host
    # Если используем network_mode: host, убираем networks и ports mapping
    volumes:
      - ../../logs:/app/logs
    networks:
      - app-network
    restart: unless-stopped

# В production не используем:
# - postgres (используем внешний на хосте)
# - prometheus, grafana, loki, promtail (опционально, можно использовать внешние экземпляры)

networks:
  app-network:
    driver: bridge
